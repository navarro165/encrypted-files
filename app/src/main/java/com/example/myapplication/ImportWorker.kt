package com.example.myapplication

import android.content.Context
import android.net.Uri
import android.util.Log
import androidx.work.*
import java.io.File
import java.io.FileOutputStream
import java.io.BufferedInputStream
import java.util.concurrent.TimeUnit
import javax.crypto.Cipher
import javax.crypto.CipherInputStream

/**
 * WorkManager worker for handling background file imports.
 * Ensures import operations complete even when app goes to background.
 */
class ImportWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {
    
    companion object {
        private const val KEY_SOURCE_URI = "source_uri"
        private const val KEY_FILENAME = "filename"
        
        fun createWorkRequest(
            sourceUri: String,
            filename: String
        ): OneTimeWorkRequest {
            val inputData = Data.Builder()
                .putString(KEY_SOURCE_URI, sourceUri)
                .putString(KEY_FILENAME, filename)
                .build()
            
            return OneTimeWorkRequestBuilder<ImportWorker>()
                .setInputData(inputData)
                .setBackoffCriteria(BackoffPolicy.LINEAR, 10, TimeUnit.SECONDS)
                .setConstraints(
                    Constraints.Builder()
                        .setRequiresBatteryNotLow(false)
                        .setRequiresCharging(false)
                        .setRequiresDeviceIdle(false)
                        .setRequiresStorageNotLow(false)
                        .build()
                )
                .build()
        }
    }
    
    override suspend fun doWork(): Result {
        val sourceUri = inputData.getString(KEY_SOURCE_URI)
        val filename = inputData.getString(KEY_FILENAME)
        
        if (sourceUri == null || filename == null) {
            Log.e("ImportWorker", "Invalid input data")
            return Result.failure()
        }
        
        return try {
            // Update progress
            setForeground(createForegroundInfo("Importing $filename...", 0, 100))
            
            // Import and encrypt the file
            val success = importAndEncryptFile(Uri.parse(sourceUri), filename)
            
            if (success) {
                // Final progress update
                setForeground(createForegroundInfo("Import completed: $filename", 100, 100))
                Log.i("ImportWorker", "Import completed successfully: $filename")
                
                // Notify MainActivity to refresh the file list
                notifyImportCompleted(filename, true)
                
                Result.success()
            } else {
                setForeground(createForegroundInfo("Import failed: $filename", 0, 100))
                Log.e("ImportWorker", "Import failed: $filename")
                
                // Notify MainActivity about the failure
                notifyImportCompleted(filename, false)
                
                Result.failure()
            }
            
        } catch (e: Exception) {
            Log.e("ImportWorker", "Import failed: ${e.message}")
            setForeground(createForegroundInfo("Import failed: $filename", 0, 100))
            
            // Notify MainActivity about the failure
            notifyImportCompleted(filename, false)
            
            Result.failure()
        }
    }
    
    private fun importAndEncryptFile(sourceUri: Uri, filename: String): Boolean {
        return try {
            val secureKeyManager = SecureKeyManager(applicationContext)
            
            // Read source file
            val inputStream = applicationContext.contentResolver.openInputStream(sourceUri)
            if (inputStream == null) {
                Log.e("ImportWorker", "Could not open input stream for $sourceUri")
                return false
            }
            
            // Get file size for progress tracking
            val fileSize = getFileSize(sourceUri)
            
            // Create encrypted file
            val encryptedFile = File(applicationContext.filesDir, "encrypted_files/$filename")
            encryptedFile.parentFile?.mkdirs()
            
            // Encrypt and save using CipherInputStream for consistency
            inputStream.use { input ->
                FileOutputStream(encryptedFile).use { outputStream ->
                    // Get encryption cipher (let it generate its own IV)
                    val cipher = secureKeyManager.getEncryptionCipher()
                    
                    // Extract the IV that was generated by the cipher
                    val iv = cipher.iv
                    Log.d("ImportWorker", "Generated IV: ${iv.size} bytes")
                    
                    // Write IV (12 bytes)
                    outputStream.write(iv)
                    
                    // Use CipherInputStream for consistent encryption/decryption
                    BufferedInputStream(input, 65536).use { bufferedInput ->
                        CipherInputStream(bufferedInput, cipher).use { cipherInput ->
                            val buffer = ByteArray(65536) // 64KB buffer
                            var bytesRead: Int
                            var totalBytesRead = 0L
                            
                            while (cipherInput.read(buffer).also { bytesRead = it } != -1) {
                                outputStream.write(buffer, 0, bytesRead)
                                totalBytesRead += bytesRead
                                
                                // Update progress every 100KB
                                if (totalBytesRead % (100 * 1024) == 0L) {
                                    val progress = ((totalBytesRead.toFloat() / fileSize) * 100).toInt()
                                    Log.d("ImportWorker", "Import progress: $progress%")
                                }
                            }
                            
                            Log.d("ImportWorker", "Encryption completed. Total bytes written: $totalBytesRead")
                        }
                    }
                }
            }
            
            // Verify the file was actually written
            val finalFileSize = encryptedFile.length()
            Log.d("ImportWorker", "Final encrypted file size: $finalFileSize bytes")
            
            if (finalFileSize <= 12) { // Only IV was written, no data
                Log.e("ImportWorker", "Encrypted file is too small (only IV), import failed")
                encryptedFile.delete() // Clean up the corrupted file
                return false
            }
            
            true
            
        } catch (e: Exception) {
            Log.e("ImportWorker", "Error importing file: ${e.message}", e)
            // Clean up any partially written file
            try {
                val encryptedFile = File(applicationContext.filesDir, "encrypted_files/$filename")
                if (encryptedFile.exists()) {
                    encryptedFile.delete()
                }
            } catch (cleanupException: Exception) {
                Log.w("ImportWorker", "Failed to cleanup corrupted file: ${cleanupException.message}")
            }
            false
        }
    }
    
    private fun getFileSize(uri: Uri): Long {
        return try {
            applicationContext.contentResolver.openFileDescriptor(uri, "r")?.use { pfd ->
                pfd.statSize
            } ?: 0L
        } catch (e: Exception) {
            Log.w("ImportWorker", "Could not get file size: ${e.message}")
            0L
        }
    }
    
    private fun createForegroundInfo(message: String, current: Int, total: Int): ForegroundInfo {
        val progress = if (total > 0) (current * 100 / total) else 0
        
        val notification = androidx.core.app.NotificationCompat.Builder(applicationContext, "import_channel")
            .setContentTitle("File Import")
            .setContentText(message)
            .setSmallIcon(android.R.drawable.ic_menu_upload)
            .setProgress(100, progress, false)
            .setOngoing(true)
            .setAutoCancel(false)
            .build()
        
        return ForegroundInfo(1002, notification, android.content.pm.ServiceInfo.FOREGROUND_SERVICE_TYPE_DATA_SYNC)
    }
    
    private fun notifyImportCompleted(filename: String, success: Boolean) {
        try {
            // Use LocalBroadcastManager for reliable in-app communication
            val localIntent = android.content.Intent("com.example.myapplication.IMPORT_COMPLETED_LOCAL")
            localIntent.setPackage(applicationContext.packageName) // XSECURITY FI: Make intent explicit
            // Add the specific filename to track individual completions
            localIntent.putExtra("completed_filename", filename)
            localIntent.putExtra("success", success) // Pass success status
            androidx.localbroadcastmanager.content.LocalBroadcastManager.getInstance(applicationContext)
                .sendBroadcast(localIntent)
            Log.d("ImportWorker", "Import completion notification sent successfully for: $filename, success: $success")
        } catch (e: Exception) {
            Log.w("ImportWorker", "Could not send import completion notification: ${e.message}")
        }
    }
} 